-- FIXED SCRIPT: Seed Data BEFORE adding Foreign Key
BEGIN;

-- 1. Drop the table (CASCADE will drop dependent FKs temporarily)
DROP TABLE IF EXISTS public.loan_plans CASCADE;

-- 2. Create the table from scratch with INTEGER ID
CREATE TABLE public.loan_plans (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- Changed to BY DEFAULT to allow manual insert if needed
    created_at TIMESTAMPTZ DEFAULT NOW(),
    name TEXT NOT NULL,
    principal_amount NUMERIC NOT NULL,
    duration_months INTEGER NOT NULL,
    interest_rate NUMERIC DEFAULT 0, 
    installment_amount NUMERIC NOT NULL
);

-- 3. Seed Data IMMEDIATELY (so ID 1 exists for the Foreign Key)
-- We force ID=1 to match existing loans that likely reference plan_id=1
INSERT INTO public.loan_plans (id, name, principal_amount, duration_months, interest_rate, installment_amount)
VALUES (1, 'Starter Loan', 20000, 12, 20, 2000)
ON CONFLICT (id) DO NOTHING;

-- Reset the sequence so next insert is 2
SELECT setval(pg_get_serial_sequence('public.loan_plans', 'id'), (SELECT MAX(id) FROM public.loan_plans));

-- 4. Restore Foreign Key in 'loans' table
DO $$
BEGIN
    IF EXISTS (SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename = 'loans') THEN
        ALTER TABLE public.loans 
        DROP CONSTRAINT IF EXISTS loans_plan_id_fkey;

        ALTER TABLE public.loans
        ADD CONSTRAINT loans_plan_id_fkey
        FOREIGN KEY (plan_id)
        REFERENCES public.loan_plans(id)
        ON DELETE SET NULL;
    END IF;
END $$;

-- 5. Enable RLS & Permissions
ALTER TABLE public.loan_plans ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Enable full access for authenticated users"
ON public.loan_plans
FOR ALL
TO authenticated
USING (true)
WITH CHECK (true);

GRANT ALL ON public.loan_plans TO postgres, anon, authenticated, service_role;

COMMIT;
